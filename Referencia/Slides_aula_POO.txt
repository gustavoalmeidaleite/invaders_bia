Com base nos arquivos fornecidos (especialmente o CSV que contém os metadados textuais precisos e o PDF/JPG para a estrutura visual), aqui está a transcrição detalhada do Diagrama UML em Markdown.

Esta estrutura foi formatada especificamente para ser consumida por uma LLM (como eu) para gerar código, separando claramente a **Lógica de Negócio (Business)** da **Estrutura de Dados (Dados)**, conforme proposto no diagrama.

---

# Especificação Técnica de Arquitetura: Space Invaders (Padrão Business/Data)

## 1. Visão Geral da Arquitetura
O sistema segue um padrão de projeto que desacopla o estado (dados) do comportamento (regras de negócio).
* **Camada de Dados (Dados):** Classes responsáveis apenas por armazenar o estado (coordenadas, propriedades físicas, retângulos do Pygame).
* **Camada de Negócio (Business):** Classes que contêm a lógica de manipulação dos dados (movimentação, regras de disparo, cálculos).
* **Orquestrador (Jogo):** A classe central que instancia as entidades, gerencia o loop principal (`main loop`) e injeta as dependências de negócio.

---

## 2. Classe Principal (Orquestrador)

### Classe: `Jogo`
Responsável por gerenciar o ciclo de vida da aplicação, inicialização e loop principal.

**Atributos:**
* `tela`: `pygame.Surface` — A superfície de renderização principal.
* `clock`: `pygame.time.Clock` — Controle de FPS.
* `rodando`: `bool` — Flag de controle do loop do jogo.
* `estado`: `int` — Inteiro representando o estado atual (Menu, Jogando, Game Over).
* `jogador`: `Jogador` — Instância da entidade Jogador.
* `jogador_business`: `JogadorBusiness` — Instância da lógica do jogador.
* `inimigos`: `List[Inimigo]` — Lista de entidades de inimigos.
* `inimigo_business`: `InimigoBusiness` — Lógica compartilhada ou gerenciadora dos inimigos.
* `projetil_business`: `ProjetilBusiness` — Lógica para gerenciamento de projéteis.
* `pontuacao`: `Pontuacao` — Entidade de dados da pontuação.
* `pontuacao_business`: `PontuacaoBusiness` — Lógica de pontuação.
* `menu`: `Menu` — Objeto responsável pela tela de menu.
* `game_over`: `GameOver` — Objeto responsável pela tela de fim de jogo.
* `efeitos_explosao`: `List` — Lista para gerenciar animações/partículas de explosão.

**Métodos:**
* `__init__()` — Construtor.
* `inicializar_jogo(): void` — Configura o estado inicial (reset).
* `criar_inimigos(): List` — Gera a grade/lista inicial de inimigos.
* `processar_eventos(): void` — Trata inputs do usuário (teclado/mouse) e eventos do Pygame.
* `atualizar(): void` — Chama os métodos de atualização (update) das camadas de negócio.
* `desenhar(): void` — Renderiza os estados atuais na `tela`.
* `verificar_colisoes(): void` — Detecta interações entre retângulos (tiros vs inimigos, inimigos vs jogador).
* `executar(): void` — O método que contém o `while rodando:` (Game Loop).

---

## 3. Módulos de Entidades (Pares Dados/Business)

### 3.1. Entidade: Jogador

#### `Jogador Dados`
Responsável pelo estado cru do jogador.
**Atributos:**
* `x`: `int` — Posição X.
* `y`: `int` — Posição Y.
* `largura`: `int` — Largura do sprite/hitbox.
* `altura`: `int` — Altura do sprite/hitbox.
* `velocidade`: `int` — Velocidade de deslocamento em pixels.
* `rect`: `pygame.Rect` — Objeto Rect do Pygame para colisão e desenho.
* `tiros`: `list<Projétil>` — Lista de projéteis disparados pelo jogador.

#### `Jogador Business`
Responsável pela lógica de controle do jogador.
**Métodos:**
* `mover_esquerda(self)`: Atualiza `x` negativo baseado na velocidade.
* `mover_direita(self)`: Atualiza `x` positivo baseado na velocidade.
* `mover_cima(self)`: (Opcional no Space Invaders clássico, mas presente no diagrama).
* `mover_baixo(self)`: (Opcional no Space Invaders clássico, mas presente no diagrama).
* `atualizar_tiros(self)`: Atualiza a posição dos tiros na lista e remove os que saíram da tela.
* `atirar(self)`: Cria uma nova instância de `Projétil` e adiciona à lista `tiros`.

---

### 3.2. Entidade: Inimigo

#### `Inimigo Dados`
Responsável pelo estado de um único inimigo.
**Atributos:**
* `x`: `int`
* `y`: `int`
* `largura`: `int`
* `altura`: `int`
* `rect`: `pygame.Rect`
* `direção`: `int` — Multiplicador (1 ou -1) para movimento lateral.
* `tipo`: `int` — Identificador do tipo de inimigo (para definir sprite ou pontuação).

#### `Inimigo Business`
Responsável pela lógica de IA e movimento dos inimigos.
**Métodos:**
* `mover(self)`: Lógica de "patrulha" (move lateralmente, desce ao bater na borda).
* `atirar_aleatorio(self)`: Define logicamente se e quando um inimigo deve disparar um projétil.

---

### 3.3. Entidade: Projétil

#### `Projétil Dados`
Representa um tiro (seja do jogador ou inimigo).
**Atributos:**
* `x`: `int`
* `y`: `int`
* `largura`: `int`
* `altura`: `int`
* `rect`: `pygame.Rect`
* `eh_inimigo`: `boolean` — Flag para identificar se causa dano ao jogador ou aos inimigos.

#### `Projétil Business`
**Métodos:**
* `mover_projeteis(self)`: Atualiza a posição Y do projétil (para cima se jogador, para baixo se inimigo).
* `verificar_colisao(self)`: (Pode estar aqui ou delegado ao `Jogo`, mas o diagrama lista métodos de verificação).

---

### 3.4. Entidade: Pontuação (Score)

#### `Pontuacao Dados`
Armazena o estado do progresso do jogo.
**Atributos:**
* `pontos`: `int {property}` — Valor atual da pontuação.
* `vidas_jogador`: `int {property}` — Contagem de vidas restantes.
**Métodos Privados/Setters:**
* `definir_pontos(pontos): void`
* `definir_vidas(vidas): void`

#### `pontuacao business`
Regras para ganho de pontos e condições de derrota.
**Métodos:**
* `adicionar_pontos(pontos): void`: Incrementa o score.
* `remover_vida(): void`: Decrementa vidas do jogador.
* `resetar_pontuacao(): void`: Zera o estado para novo jogo.
* `calcular_pontos_inimigo(tipo): int`: Retorna valor baseada no `tipo` do inimigo.
* `adicionar_pontos_inimigo(tipo): void`: Facade que usa o cálculo acima e adiciona ao total.
* `adicionar_bonus_interceptacao(): void`: Lógica específica para bônus (ex: destruir tiro inimigo ou nave mãe).
* `verificar_game_over(): bool`: Retorna `True` se vidas <= 0.
* `obter_status_jogo(): dict`: Retorna um dicionário com o estado atual (ex: `{'pontos': 100, 'vidas': 3}`) para a UI.

---

## 4. Entry Point

### `main`
* Função global `+main()` que instancia a classe `Jogo` e chama `jogo.executar()`.

---

## Observações de Implementação para LLM
1.  **Tipagem:** O diagrama usa tipagem explícita (Python Type Hints são recomendados). Note o uso de `list<Projétil>` (Generics).
2.  **Pygame:** As classes de Dados (`... Dados`) possuem dependência direta de `pygame.Rect`.
3.  **Encapsulamento:** A classe `Pontuacao Dados` utiliza *properties* (`{property}`), sugerindo o uso de decoradores `@property` e `@setter` em Python para `pontos` e `vidas_jogador`.
4.  **Fluxo de Dados:** O `Jogo` (Controller) deve ler os dados de `[Entidade] Dados` e passá-los para `[Entidade] Business` executar a lógica, ou as classes de Business devem receber a instância de Dados no construtor. O diagrama sugere composição.