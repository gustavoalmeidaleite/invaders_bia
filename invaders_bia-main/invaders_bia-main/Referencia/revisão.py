# -*- coding: utf-8 -*-
"""Revisão.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1piN1aNQ1kNDXAaUshhOwt-K3zFy_pGbN

# **Revisão para a Prova teórica de POO - 25/11/2015**

1) Explique o que é Encapsulamento, por que usálo e como implementá-lo em Python. Como ficaria o Diagrama de Classe e o código da classe Produto com os atributos 'nome', 'código' e 'valor'?

R. Encapsulamento é uma técnica usada para proteger o acesso direto e indevido aos atributos, privando-os, e deixando-os acessíveis por meio de métodos públicos para leitura (get) e escrita (set).
"""

class Produto:

  def __init__(self, nome, codigo, valor):
    self.__nome = nome
    self.__codigo = codigo
    self.__valor = valor

  @property       #getter Refere-se à Propriedade __nome da Classe Produto
  def nome(self):
    return self.__nome

  @nome.setter    #setter Refere-se à Propriedade __nome da Classe Produto
  def nome(self, nome):
    self.__nome = nome

  @property
  def codigo(self):
    return self.__codigo

  @codigo.setter
  def codigo(self, cod):
    self.__codigo = cod

  @property
  def valor(self):
    return self.__valor

  @valor.setter
  def valor(self, valor):
    self.__valor = valor


# Diagrama de Classe :)

#------------#
#  Produto   #
#------------#
# - nome     #
# - codigo   #
# - valor    #
#------------#

"""2) Explique a diferença conceitual e prática entre Interface e Classe Abstrata.
Explique uma situação em que se deve usar uma Interface e em que se deve usar uma Classe Abstrata. Faça um exemplo de cada.

R. Interface é uma estrutua de código orientado a objetos que possui declaração de métodos apenas (somente métodos abstratos). A Classe Abstrata é uma classe que deve possuir ao menos um método abstrato e ao menos um método concreto. Assim como a Interface, a Classe Abstrata não pode ser instanciada.

Deve-se usar uma Interface quando é necessário um contrato sem que haja qualquer implementação para as classes filhas.
Deve-se usar uma Classe Abstrata quando é possível ou necessário compartilhar um comportamento (método) comum às classes filhas.
"""

from abc import ABC, abstractmethod
class InterfaceEmbalagem(ABC):   #INTERFACE

  @abstractmethod
  def imprimirValidade():
    pass

  @abstractmethod
  def descricao():
    pass

from abc import ABC, abstractmethod
class Embalagem(ABC):   #CLASSE ABSTRATA

  def __init__(self, modelo):
    self.__modelo = modelo

  @abstractmethod
  def imprimirValidade():
    pass

  def descricao():
    return "Descricao do produto X."

"""8) O que é polimorfismo em POO, dê exemplos.

R. Polimorfismo é uma característica de POO, na qual é possivel determinar comportamentos (o que deve ser feito) em classes ou interfaces, que funcionam como contrato para classes filhas que implementam os métodos abstratos, da forma conveniente (como fazer). Dessa forma, classes filhas fazem coisas em comum, mas de formas diferentes. É importante destacar também que um objeto especializado também pode se passar por um objeto mais simples da sua cadeia hierárquica (um 'Cliente' ou um 'Funcionario' é uma 'PessoaFísica').


"""

class ProdutoPerecivel(Produto, Embalagem):

  def __init__(self, nome, codigo, valor, validade, fabricacao):
    super().__init__(nome, codigo, valor)
    self.__validade = validade
    self.__fabricacao = fabricacao

  @property
  def validade(self):
    return self.__validade

  @validade.setter
  def validade(self, validade):
    self.__validade = validade

  @property
  def fabricacao(self):
    return self.__fabricacao

  @fabricacao.setter
  def fabricacao(self, fabricacao):
    self.__fabricacao = fabricacao

  def imprimirValidade(self):
    return "Válido até amanhã."

class ProdutoNaoPerecivel(Produto, Embalagem):

  def __init__(self, nome, codigo, valor, fabricante):
    super().__init__(nome, codigo, valor)
    self.__fabricante = fabricante

  @property
  def fabricante(self):
    return self.__fabricante

  @fabricante.setter
  def fabricante(self, fabricante):
    self.__fabricante = fabricante

  def imprimirValidade(self):
    return "Válido para sempre."

pp = ProdutoPerecivel("ProdutoA", 1, 10.99, "29/11/2023", "29/10/2023")
pp.nome = "ProdutoAA"
print(pp.nome)
print(pp.imprimirValidade())

pnp = ProdutoNaoPerecivel("ProdutoB", 2, 12.99, "P&G")
print(pnp.imprimirValidade())

"""3) O SRP (Single Responsability Principle) diz que classes devem ter uma única responsabilidade. Considere um software que grava/lê/atualiza/deleta dados de um produto no BD; gera views/relatórios sobre o estoque; apresenta as informações dos produtos por meio de páginas HTML; e usa uma API Restfull para receber as requisições da view. Como você iria estruturar o seu projeto (em pastas/camadas) e justifique a sua resposta.

R. Usaria as seguintes camadas/pastas:
- app/estatic: para arquivos estáticos como imagens, css, html, js...
- app/estatic/view: para páginas html
- app/api.py: a classe responsável pelos endpoints na pasta que contem as demais pastas (como um front-controller).
- app/model: pasta para as classes de dados.
- app/dao: pasta para as classes responsáveis pelas operações com o BD.
- app/business: pasta para as classes com as regras de negócio, se for muito complexas (cálculos, descontos, validações, etc.)
- app/reports: pasta para colocar os relatórios.
- na raiz, colocar o arquivo executável.

4) Em Engenharia de Software, sempre se deve preferir Composição à Herança. Algumas justificativas são: flexibilidade em tempo de execução (qual é mais flexível e por quê?); qual estrutura tem maior ou menor acoplamento (justifique); em sistemas complexos/grandes, pode acontecer a explosão de classes (imagine veículos, moto, carro, ônibus e caminhão convencionais e autônomos) o que isso significa para essas duas estruturas; e considerando testes de software, em qual estrutura seria mais fácil testar as classes?

R.

5) Diferencie classe de objeto.

R. Classe é uma estrutura na qual se define os comportamentos e as características de objetos (classe de objetos). Pode-se representar por meio de código-fonte e Diagrama de Classe. Já um objeto é uma instanciação da classe, ou seja um espaço de memória reservado para armazenar as características e executar os comportamentos do objeto.

6) Diferencie uma agregação de uma composição.

R. Agregação é um relacionamento (tipo de associação) em que a vida do todo e da parte são independentes. Em UML representa-se com um losângulo aberto, ao lado do todo, ligando com uma linha a classe das partes. Já a Composição é um tipo de associação na qual a vida da parte é dependente da vida do todo (container), de modo que eles precisam um do outro para coexistir. Representa-se no Diagrama de Classe por um losângulo fechado no lado do todo, ligando à classe das partes por uma linha.

7) Explique a navegabilidade em um diagrama de classe (seta que aponta para outra classe).

R. A navegabilidade indica que a classe da qual parte a seta, conhece a que recebe a seta; ou seja, se um objeto Livro tem a sua classe apontando para a classe Editora, isso significa que o objeto Livro possui um objeto Editora no seu corpo.

9) Defina e explique quais são os tipos de relacionamentos em um diagrama de classe.

R. - Associação (simples) é representada por uma linha, podendo navegar (usar a seta) em qualquer ou todos os sentidos. Indica que um objeto possui relação / conhece outro.
- Agregação - ver questão 6.
- Composição - ver questão 6.
- Herança é um relacionamento que indica especialização entre classes; em UML coloca-se um triângulo vazio na classe mãe ligando por uma linha, a classe filha (mais especializada).
- Implementação é o ralacionamento entre uma interface e uma classe. Nela há um triânglo vazio na interface e uma linha tracejada apontando para a classe.
- Realização é o relacionamento entre uma classe abstrata e uma classe concreta. É representada como uma herança.
- Delegação é um relacionamento entre classes em que uma delega o comportamento para outra (usa o serviço da outra). Em UML é representada por uma seta aberta com linha tracejada, apondando para a classe que possui de fato executa o  método.

10) Defina o que é acoplamento e coesão em POO.

R. O Acoplamento é uma situação em que uma classe é afetada pela mudança em outra classe. Quanto maior o acoplamento, mais difícil fica a manutenção nas classes acopladas. Já a Coesão indica o grau de responsabilidade que uma classe possui, em síntese, quanto mais específico e simples as responsabilidades, melhor a sustentação/manutenção do sistema.
"""