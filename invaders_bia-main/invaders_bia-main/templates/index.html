<!--
================================================================================
Template: index.html - Interface Principal do Jogo (Canvas + Socket.IO)
================================================================================

DESCRIÇÃO:
    Página principal do Space Invaders Web. Renderiza o jogo em um elemento
    Canvas HTML5 e comunica com o servidor via Socket.IO em tempo real.

ARQUITETURA:
    ┌─────────────────┐     Socket.IO      ┌─────────────────┐
    │   Cliente Web   │ ◄─────────────────► │  Servidor Flask │
    │  (Este arquivo) │    estado_jogo     │    (app.py)     │
    │                 │    input_jogador   │                 │
    └─────────────────┘                    └─────────────────┘

COMPONENTES:
    1. Canvas HTML5 (800x600) - Área de renderização do jogo
    2. Socket.IO Client - Comunicação em tempo real
    3. Sistema de Sprites - Imagens carregadas de /static/
    4. Sistema de Input - Teclado com suporte a teclas contínuas
    5. Renderização - Menu, Jogo, Game Over, Config IA

ESTADOS DO JOGO:
    - 'menu': Tela inicial com opções
    - 'jogando': Jogo em andamento (pode estar pausado)
    - 'game_over': Tela de fim de jogo

CONTROLES:
    - WASD ou Setas: Movimentar nave
    - Z ou Espaço: Atirar
    - P: Pausar/Retomar
    - ESC: Voltar ao menu
    - R: Reiniciar jogo

EVENTOS SOCKET.IO:
    - 'connect': Conexão estabelecida
    - 'disconnect': Conexão perdida
    - 'estado_jogo': Recebe estado do servidor (~30 FPS)
    - 'input_jogador': Envia comandos ao servidor

SPRITES UTILIZADOS (carregados de /static/):
    - player_ship.png: Nave do jogador
    - invader_type1/2/3.png: Tipos de inimigos
    - bullet_player.png: Tiro do jogador
    - bullet_enemy.png: Tiro dos inimigos
    - explosion.png: Efeito de explosão
    - background.png: Fundo do jogo (opcional)
================================================================================
-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders Web</title>

    <!-- ================================================================
         ESTILOS CSS - Tema escuro estilo arcade
         ================================================================ -->
    <style>
        /* Container principal - centraliza o canvas na tela */
        body {
            background-color: #222;
            /* Fundo escuro */
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Courier New', Courier, monospace;
            /* Fonte arcade */
        }

        /* Canvas do jogo - onde tudo é renderizado */
        canvas {
            background-color: black;
            border: 2px solid #444;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
            /* Brilho verde sutil */
        }

        /* Área de status da conexão */
        #status {
            margin-top: 10px;
            font-size: 14px;
            color: #888;
        }
    </style>

    <!-- Socket.IO Client Library (CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
</head>

<body>
    <!-- Título do jogo -->
    <h1>Space Invaders</h1>

    <!-- Canvas onde o jogo é renderizado (800x600 pixels) -->
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <!-- Status da conexão com o servidor -->
    <div id="status">Connecting...</div>

    <!-- ================================================================
         JAVASCRIPT - Lógica do Cliente
         ================================================================ -->
    <script>
        // ============================================================
        // INICIALIZAÇÃO - Socket.IO e Canvas
        // ============================================================

        // Conecta ao servidor Socket.IO (mesmo host)
        const socket = io();

        // Referências ao canvas e contexto 2D
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');

        // ============================================================
        // CARREGAMENTO DE SPRITES
        // Imagens são carregadas de /static/ e usadas na renderização
        // ============================================================
        const sprites = {
            player: new Image(),      // Nave do jogador
            enemy1: new Image(),      // Inimigo tipo 1 (linha superior, 30 pts)
            enemy2: new Image(),      // Inimigo tipo 2 (linha média, 20 pts)
            enemy3: new Image(),      // Inimigo tipo 3 (linha inferior, 10 pts)
            bulletPlayer: new Image(), // Projétil do jogador (sobe)
            bulletEnemy: new Image(),  // Projétil do inimigo (desce)
            explosion: new Image(),    // Efeito de explosão
            background: new Image()    // Fundo (opcional)
        };

        // Define caminhos dos sprites
        sprites.player.src = '/static/player_ship.png';
        sprites.enemy1.src = '/static/invader_type1.png';
        sprites.enemy2.src = '/static/invader_type2.png';
        sprites.enemy3.src = '/static/invader_type3.png';
        sprites.bulletPlayer.src = '/static/bullet_player.png';
        sprites.bulletEnemy.src = '/static/bullet_enemy.png';
        sprites.explosion.src = '/static/explosion.png';
        sprites.background.src = '/static/background.png';

        // ============================================================
        // SISTEMA DE INPUT - Gerenciamento de Teclas
        // ============================================================

        // Set de teclas atualmente pressionadas (para movimento contínuo)
        const pressedKeys = new Set();

        // Estado atual do jogo (recebido do servidor)
        let estadoAtual = 'menu';

        // Controle da tela de configuração de IA (processada localmente)
        let telaConfigIA = false;
        let configIA = {
            layers: 2,           // Número de camadas ocultas da rede neural
            neuronios: 16,       // Neurônios por camada
            campoSelecionado: 0  // Campo atualmente selecionado (0=layers, 1=neurônios)
        };

        // Opção selecionada no menu principal
        let menuSelecionada = 0;

        /**
         * Verifica se uma tecla deve ter comportamento padrão prevenido.
         * Evita que setas e espaço rolem a página durante o jogo.
         */
        const shouldPreventDefault = (key) => (
            ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' ', 'a', 'd', 'w', 's', 'A', 'D', 'W', 'S', 'z', 'Z'].includes(key)
        );

        /**
         * Envia uma ação ao servidor via Socket.IO.
         * 
         * @param {string} acao - Nome da ação (ex: 'esquerda', 'atirar')
         * @param {string} estado - 'pressionar' ou 'soltar' (para teclas contínuas)
         */
        function emitirAcao(acao, estado = 'pressionar') {
            if (!acao) return;

            // Ações da tela de configuração de IA são processadas localmente
            if (acao.startsWith('config_ia_')) {
                processarConfigIA(acao);
                return;
            }

            // Intercepta seleção de "JOGAR COM IA" para mostrar tela de config
            if (acao === 'menu_selecionar' && estadoAtual === 'menu' && menuSelecionada === 0) {
                telaConfigIA = true;
                configIA.campoSelecionado = 0;
                return;
            }

            // Envia ação para o servidor processar
            socket.emit('input_jogador', { acao, estado });
        }

        /**
         * Processa ações da tela de configuração de IA (local).
         * Permite ajustar layers e neurônios da rede neural.
         */
        function processarConfigIA(acao) {
            if (acao === 'config_ia_cima') {
                // Move para campo anterior
                configIA.campoSelecionado = Math.max(0, configIA.campoSelecionado - 1);
            } else if (acao === 'config_ia_baixo') {
                // Move para próximo campo
                configIA.campoSelecionado = Math.min(1, configIA.campoSelecionado + 1);
            } else if (acao === 'config_ia_menos') {
                // Diminui valor do campo selecionado
                if (configIA.campoSelecionado === 0) {
                    configIA.layers = Math.max(1, configIA.layers - 1);
                } else if (configIA.campoSelecionado === 1) {
                    configIA.neuronios = Math.max(8, configIA.neuronios - 1);
                }
            } else if (acao === 'config_ia_mais') {
                // Aumenta valor do campo selecionado
                if (configIA.campoSelecionado === 0) {
                    configIA.layers = Math.min(10, configIA.layers + 1);
                } else if (configIA.campoSelecionado === 1) {
                    configIA.neuronios = Math.min(256, configIA.neuronios + 1);
                }
            } else if (acao === 'config_ia_selecionar') {
                // Confirma e inicia o jogo
                telaConfigIA = false;
                socket.emit('input_jogador', { acao: 'menu_selecionar', estado: 'pressionar' });
            } else if (acao === 'config_ia_voltar') {
                // Volta ao menu sem iniciar
                telaConfigIA = false;
            }
            // Re-renderiza a tela de configuração
            renderConfigIA();
        }

        /**
         * Resolve qual ação corresponde a uma tecla pressionada.
         * Retorna objeto com: acao, tipo ('single' ou 'cont'), prevent
         * 
         * @param {string} key - Código da tecla (event.key)
         * @returns {Object|null} Informação da ação ou null se não mapeada
         */
        function resolverAcao(key) {
            const isMenu = estadoAtual === 'menu';
            const isGameOver = estadoAtual === 'game_over';
            const isJogando = estadoAtual === 'jogando';

            // ========================================
            // AÇÕES GLOBAIS (funcionam em qualquer estado)
            // ========================================
            if (key === 'p' || key === 'P') return { acao: 'pausar', tipo: 'single', prevent: true };
            if (key === 'Escape') return { acao: 'menu', tipo: 'single', prevent: true };
            if (key === 'r' || key === 'R') return { acao: 'reiniciar', tipo: 'single', prevent: true };

            // ========================================
            // TELA DE CONFIGURAÇÃO DE IA (local)
            // ========================================
            if (telaConfigIA) {
                if (['ArrowUp', 'w', 'W'].includes(key)) return { acao: 'config_ia_cima', tipo: 'single', prevent: true };
                if (['ArrowDown', 's', 'S'].includes(key)) return { acao: 'config_ia_baixo', tipo: 'single', prevent: true };
                if (['ArrowLeft', 'a', 'A'].includes(key)) return { acao: 'config_ia_menos', tipo: 'single', prevent: true };
                if (['ArrowRight', 'd', 'D'].includes(key)) return { acao: 'config_ia_mais', tipo: 'single', prevent: true };
                if (key === ' ' || key === 'Enter') return { acao: 'config_ia_selecionar', tipo: 'single', prevent: true };
                if (key === 'Escape') return { acao: 'config_ia_voltar', tipo: 'single', prevent: true };
                return null;
            }

            // ========================================
            // NAVEGAÇÃO DE MENUS (principal e game over)
            // ========================================
            if (isMenu || isGameOver) {
                if (['ArrowUp', 'w', 'W'].includes(key)) return { acao: 'menu_cima', tipo: 'single', prevent: true };
                if (['ArrowDown', 's', 'S'].includes(key)) return { acao: 'menu_baixo', tipo: 'single', prevent: true };
                if (key === ' ' || key === 'Enter') return { acao: 'menu_selecionar', tipo: 'single', prevent: true };
                return null;
            }

            // ========================================
            // CONTROLES DO JOGO (teclas contínuas)
            // ========================================
            switch (key) {
                // Movimento para esquerda
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    return { acao: 'esquerda', tipo: 'cont', prevent: true };

                // Movimento para direita
                case 'ArrowRight':
                case 'd':
                case 'D':
                    return { acao: 'direita', tipo: 'cont', prevent: true };

                // Movimento para cima
                case 'ArrowUp':
                case 'w':
                case 'W':
                    return { acao: 'cima', tipo: 'cont', prevent: true };

                // Movimento para baixo
                case 'ArrowDown':
                case 's':
                case 'S':
                    return { acao: 'baixo', tipo: 'cont', prevent: true };

                // Atirar (contínuo enquanto pressionado)
                case ' ':
                case 'z':
                case 'Z':
                    return { acao: 'atirar', tipo: 'cont', prevent: true };

                default:
                    return null;
            }
        }

        // ============================================================
        // EVENT LISTENERS - Teclado
        // ============================================================

        /**
         * Handler de tecla pressionada (keydown).
         * - Ações 'single': executam uma vez
         * - Ações 'cont': registram tecla como pressionada
         */
        document.addEventListener('keydown', (e) => {
            const info = resolverAcao(e.key);
            if (!info) return;
            if (info.prevent && shouldPreventDefault(e.key)) e.preventDefault();

            if (info.tipo === 'cont') {
                // Tecla contínua: só emite se ainda não estava pressionada
                if (!pressedKeys.has(e.key)) {
                    pressedKeys.add(e.key);
                    emitirAcao(info.acao, 'pressionar');
                }
            } else {
                // Ação única: emite sempre
                emitirAcao(info.acao, 'pressionar');
            }
        });

        /**
         * Handler de tecla solta (keyup).
         * Apenas para ações contínuas - envia 'soltar' ao servidor.
         */
        document.addEventListener('keyup', (e) => {
            const info = resolverAcao(e.key);
            if (!info || info.tipo !== 'cont') return;
            if (info.prevent && shouldPreventDefault(e.key)) e.preventDefault();

            pressedKeys.delete(e.key);
            emitirAcao(info.acao, 'soltar');
        });

        /**
         * Handler de perda de foco da janela.
         * Libera todas as teclas para evitar movimento "preso".
         */
        window.addEventListener('blur', () => {
            pressedKeys.forEach((key) => {
                const info = resolverAcao(key);
                if (info && info.tipo === 'cont') {
                    emitirAcao(info.acao, 'soltar');
                }
            });
            pressedKeys.clear();
        });

        // ============================================================
        // SOCKET.IO EVENTS - Comunicação com Servidor
        // ============================================================

        /**
         * Evento de conexão estabelecida com o servidor.
         */
        socket.on('connect', () => {
            statusDiv.textContent = 'Connected to server';
            statusDiv.style.color = '#0f0'; // Verde = conectado
        });

        /**
         * Evento de desconexão do servidor.
         */
        socket.on('disconnect', () => {
            statusDiv.textContent = 'Disconnected from server';
            statusDiv.style.color = '#f00'; // Vermelho = desconectado
        });

        /**
         * Evento de atualização do estado do jogo.
         * Recebido do servidor ~30 vezes por segundo.
         * 
         * @param {Object} estado - Estado completo do jogo (jogador, inimigos, etc.)
         */
        socket.on('estado_jogo', (estado) => {
            // Detecta mudança de estado para limpar teclas pressionadas
            if (estado && estado.estado) {
                if (estado.estado !== estadoAtual) {
                    pressedKeys.clear();
                }
                estadoAtual = estado.estado;
            }

            // Renderiza o estado atual
            renderGame(estado);
            atualizarStatus(estado);
        });

        // ============================================================
        // FUNÇÕES DE ATUALIZAÇÃO DE UI
        // ============================================================

        /**
         * Atualiza o texto de status abaixo do canvas.
         * Mostra informações contextuais baseadas no estado do jogo.
         */
        function atualizarStatus(estado) {
            if (!estado) return;

            // Mapeamento de estados para textos de ajuda
            const mapStatus = {
                menu: 'Menu - selecione com ↑/↓ e Enter/Espaço',
                jogando: estado.pausado ? 'Jogo pausado - P para retomar' : 'Em jogo',
                game_over: 'Game over - use ↑/↓ e Enter/Espaço'
            };

            let texto = mapStatus[estado.estado] || 'Em jogo';
            let cor = '#0f0'; // Verde padrão

            // Define cor baseada no estado
            if (estado.estado === 'menu') cor = '#0ff';      // Ciano
            if (estado.estado === 'game_over') cor = '#f00'; // Vermelho
            if (estado.pausado && estado.estado === 'jogando') cor = '#ff0'; // Amarelo
            if (estado.deseja_sair) texto = 'Opção sair selecionada - feche a aba para encerrar';

            statusDiv.textContent = texto;
            statusDiv.style.color = cor;
        }

        // ============================================================
        // FUNÇÕES DE RENDERIZAÇÃO - Canvas 2D
        // ============================================================

        /**
         * Função principal de renderização.
         * Delega para funções específicas baseado no estado atual.
         */
        function renderGame(estado) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!estado) return;

            const estadoNome = estado.estado || 'jogando';

            // Tela de configuração de IA (sobrepõe tudo)
            if (telaConfigIA) {
                renderConfigIA();
                return;
            }

            // Menu principal
            if (estadoNome === 'menu') {
                renderMenu(estado.menu);
                return;
            }

            // ========================================
            // RENDERIZAÇÃO DO JOGO EM ANDAMENTO
            // ========================================

            // Fundo (opcional - descomentado se desejado)
            // ctx.drawImage(sprites.background, 0, 0, canvas.width, canvas.height);

            // Jogador (nave espacial)
            if (estado.jogador) {
                ctx.drawImage(
                    sprites.player,
                    estado.jogador.x,
                    estado.jogador.y,
                    estado.jogador.largura,
                    estado.jogador.altura
                );
            }

            // Inimigos (alienígenas)
            if (estado.inimigos) {
                estado.inimigos.forEach(inimigo => {
                    // Seleciona sprite baseado no tipo (1, 2 ou 3)
                    let sprite = sprites.enemy1;
                    if (inimigo.tipo === 2) sprite = sprites.enemy2;
                    if (inimigo.tipo === 3) sprite = sprites.enemy3;

                    ctx.drawImage(
                        sprite,
                        inimigo.x,
                        inimigo.y,
                        inimigo.largura,
                        inimigo.altura
                    );
                });
            }

            // Projéteis (tiros do jogador e inimigos)
            if (estado.projeteis) {
                estado.projeteis.forEach(projetil => {
                    let sprite = projetil.tipo === 'jogador' ? sprites.bulletPlayer : sprites.bulletEnemy;
                    ctx.drawImage(
                        sprite,
                        projetil.x,
                        projetil.y,
                        projetil.largura,
                        projetil.altura
                    );
                });
            }

            // Efeitos de explosão
            if (estado.explosões) {
                estado.explosões.forEach(explosao => {
                    const size = explosao.tamanho;
                    const offset = size / 2; // Centraliza a explosão
                    ctx.drawImage(
                        sprites.explosion,
                        explosao.x - offset,
                        explosao.y - offset,
                        size,
                        size
                    );
                });
            }

            // ========================================
            // HUD (Heads-Up Display) - Pontuação e Vidas
            // ========================================
            ctx.fillStyle = 'white';
            ctx.font = '20px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${estado.pontuacao}`, 10, 30);
            ctx.fillText(`Lives: ${estado.vidas}`, 10, 60);

            // Tela de Game Over (se aplicável)
            if (estadoNome === 'game_over') {
                renderGameOverMenu(estado.menu_game_over, estado.pontuacao);
                return;
            }

            // ========================================
            // OVERLAY DE PAUSA
            // ========================================
            if (estado.pausado) {
                // Fundo semi-transparente
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Texto "PAUSADO"
                ctx.fillStyle = '#0ff';
                ctx.font = '50px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSADO', canvas.width / 2, canvas.height / 2);

                // Instrução
                ctx.fillStyle = 'white';
                ctx.font = '20px Courier New';
                ctx.fillText('Pressione P para retomar', canvas.width / 2, canvas.height / 2 + 50);
            }
        }

        /**
         * Renderiza o menu principal.
         * Opções: JOGAR COM IA, JOGAR SOLO, SAIR
         */
        function renderMenu(menuInfo = { opcoes: ['JOGAR COM IA', 'JOGAR SOLO', 'SAIR'], selecionada: 0 }) {
            menuSelecionada = menuInfo.selecionada; // Atualiza opção selecionada

            // Fundo preto
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Título em ciano (estilo Space Invaders)
            ctx.fillStyle = '#0ff';
            ctx.font = 'italic 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('SPACE INVADERS:', canvas.width / 2, 120);
            ctx.fillText('BIA VERSION', canvas.width / 2, 180);

            // Opções do menu
            ctx.font = 'bold 36px Courier New';
            const startY = 280;
            const spacing = 55;

            menuInfo.opcoes.forEach((opcao, idx) => {
                const selecionada = idx === menuInfo.selecionada;

                // SAIR usa cores diferentes (branco/cinza)
                if (opcao === 'SAIR') {
                    ctx.fillStyle = selecionada ? '#fff' : '#aaa';
                } else {
                    // Outras opções em amarelo quando selecionadas
                    ctx.fillStyle = selecionada ? '#ff0' : '#cc0';
                }
                ctx.fillText(opcao, canvas.width / 2, startY + idx * spacing);
            });
        }

        /**
         * Renderiza a tela de configuração de IA (local).
         * Permite ajustar arquitetura da rede neural antes de jogar.
         */
        function renderConfigIA() {
            // Fundo preto
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Título "CONFIGURAR IA" em ciano
            ctx.fillStyle = '#0ff';
            ctx.font = 'italic bold 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('CONFIGURAR IA', canvas.width / 2, 80);

            // Subtítulo explicativo
            ctx.fillStyle = '#fff';
            ctx.font = '20px Courier New';
            ctx.fillText('Configure a arquitetura da rede neural', canvas.width / 2, 130);

            // Configuração de posições
            const startX = 80;
            const valueX = 380;
            const descX = 480;
            const startY = 200;
            const spacing = 90;

            // ========================================
            // Campo: Layers (camadas ocultas)
            // ========================================
            ctx.textAlign = 'left';
            ctx.fillStyle = configIA.campoSelecionado === 0 ? '#ff0' : '#fff'; // Amarelo se selecionado
            ctx.font = 'bold 32px Courier New';
            ctx.fillText('Layers:', startX, startY);

            ctx.fillStyle = '#0ff';
            ctx.font = '32px Courier New';
            ctx.fillText(configIA.layers.toString(), valueX, startY);

            ctx.fillStyle = '#888';
            ctx.font = '18px Courier New';
            ctx.fillText('(1-10 camadas ocultas)', descX, startY);

            // ========================================
            // Campo: Neurônios (por camada)
            // ========================================
            ctx.fillStyle = configIA.campoSelecionado === 1 ? '#ff0' : '#fff'; // Amarelo se selecionado
            ctx.font = 'bold 32px Courier New';
            ctx.fillText('Neurônios:', startX, startY + spacing);

            ctx.fillStyle = '#0ff';
            ctx.font = '32px Courier New';
            ctx.fillText(configIA.neuronios.toString(), valueX, startY + spacing);

            ctx.fillStyle = '#888';
            ctx.font = '18px Courier New';
            ctx.fillText('(8-256 neurônios por camada)', descX, startY + spacing);

            // ========================================
            // Visualização da arquitetura
            // Mostra estrutura: entrada → camadas → saída
            // ========================================
            ctx.fillStyle = '#0ff';
            ctx.font = '20px Courier New';
            const arquitetura = gerarArquitetura();
            ctx.fillText('Arquitetura: ' + arquitetura, startX, canvas.height - 40);
        }

        /**
         * Gera string representando a arquitetura da rede neural.
         * Exemplo: "8 → 16 → 16 → 5" para 2 camadas de 16 neurônios
         * 
         * @returns {string} Representação da arquitetura
         */
        function gerarArquitetura() {
            const entrada = 8;  // Neurônios de entrada (dados do jogo)
            const saida = 5;    // Neurônios de saída (ações possíveis)

            let partes = [entrada.toString()];

            // Adiciona camadas ocultas
            for (let i = 0; i < configIA.layers; i++) {
                partes.push(configIA.neuronios.toString());
            }

            partes.push(saida.toString());
            return partes.join(' → ');
        }

        /**
         * Renderiza a tela de Game Over com menu de opções.
         * 
         * @param {Object} menuInfo - Opções e índice selecionado
         * @param {number} pontuacao - Pontuação final do jogador
         */
        function renderGameOverMenu(menuInfo = { opcoes: [], selecionada: 0 }, pontuacao = 0) {
            // Overlay escuro sobre o jogo
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Título "GAME OVER" em vermelho
            ctx.fillStyle = 'red';
            ctx.font = '50px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, 220);

            // Pontuação final
            ctx.fillStyle = '#fff';
            ctx.font = '24px Courier New';
            ctx.fillText(`Pontuação: ${pontuacao}`, canvas.width / 2, 260);

            // Opções do menu (JOGAR NOVAMENTE, MENU PRINCIPAL, SAIR)
            ctx.font = '28px Courier New';
            menuInfo.opcoes.forEach((opcao, idx) => {
                const selecionada = idx === menuInfo.selecionada;
                ctx.fillStyle = selecionada ? '#ff0' : '#fff'; // Amarelo se selecionado
                ctx.fillText(opcao, canvas.width / 2, 320 + idx * 50);
            });

            // Instruções de navegação
            ctx.fillStyle = '#aaa';
            ctx.font = '20px Courier New';
            ctx.fillText('Use ↑/↓ ou W/S para navegar', canvas.width / 2, 500);
            ctx.fillText('Enter ou Espaço para selecionar', canvas.width / 2, 530);
        }
    </script>
</body>

</html>