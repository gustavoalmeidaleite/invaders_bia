<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders Web</title>
    <style>
        body {
            background-color: #222;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            background-color: black;
            border: 2px solid #444;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }
        #status {
            margin-top: 10px;
            font-size: 14px;
            color: #888;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
</head>
<body>
    <h1>Space Invaders</h1>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="status">Connecting...</div>

    <script>
        const socket = io();
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');

        // Game assets
        const sprites = {
            player: new Image(),
            enemy1: new Image(),
            enemy2: new Image(),
            enemy3: new Image(),
            bulletPlayer: new Image(),
            bulletEnemy: new Image(),
            explosion: new Image(),
            background: new Image()
        };

        // Load sprites (assuming they are served from /static/)
        sprites.player.src = '/static/player_ship.png';
        sprites.enemy1.src = '/static/invader_type1.png';
        sprites.enemy2.src = '/static/invader_type2.png';
        sprites.enemy3.src = '/static/invader_type3.png';
        sprites.bulletPlayer.src = '/static/bullet_player.png';
        sprites.bulletEnemy.src = '/static/bullet_enemy.png';
        sprites.explosion.src = '/static/explosion.png';
        sprites.background.src = '/static/background.png';

        // Input handling com estados para menu, jogo e game over
        const pressedKeys = new Set();
        let estadoAtual = 'menu';
        let telaConfigIA = false;  // Tela local de configuração da IA
        let configIA = { layers: 2, neuronios: 10, campoSelecionado: 0 };  // 0=layers, 1=neuronios, 2=iniciar
        let menuSelecionada = 0;  // Guarda a opção selecionada no menu

        const shouldPreventDefault = (key) => (
            ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' ', 'a', 'd', 'w', 's', 'A', 'D', 'W', 'S', 'z', 'Z'].includes(key)
        );

        function emitirAcao(acao, estado = 'pressionar') {
            if (!acao) return;

            // Interceptar ações da tela de configuração da IA (local)
            if (acao.startsWith('config_ia_')) {
                processarConfigIA(acao);
                return;
            }

            // Interceptar seleção do menu para "JOGAR COM IA"
            if (acao === 'menu_selecionar' && estadoAtual === 'menu' && menuSelecionada === 0) {
                // Mostrar tela de configuração da IA ao invés de enviar ao servidor
                telaConfigIA = true;
                configIA.campoSelecionado = 0;
                return;
            }

            socket.emit('input_jogador', { acao, estado });
        }

        function processarConfigIA(acao) {
            if (acao === 'config_ia_cima') {
                configIA.campoSelecionado = Math.max(0, configIA.campoSelecionado - 1);
            } else if (acao === 'config_ia_baixo') {
                configIA.campoSelecionado = Math.min(2, configIA.campoSelecionado + 1);
            } else if (acao === 'config_ia_menos') {
                if (configIA.campoSelecionado === 0) {
                    configIA.layers = Math.max(1, configIA.layers - 1);
                } else if (configIA.campoSelecionado === 1) {
                    configIA.neuronios = Math.max(1, configIA.neuronios - 1);
                }
            } else if (acao === 'config_ia_mais') {
                if (configIA.campoSelecionado === 0) {
                    configIA.layers = Math.min(99, configIA.layers + 1);
                } else if (configIA.campoSelecionado === 1) {
                    configIA.neuronios = Math.min(99, configIA.neuronios + 1);
                }
            } else if (acao === 'config_ia_selecionar') {
                if (configIA.campoSelecionado === 2) {
                    // INICIAR - sair da tela de config e iniciar o jogo
                    telaConfigIA = false;
                    socket.emit('input_jogador', { acao: 'menu_selecionar', estado: 'pressionar' });
                }
            } else if (acao === 'config_ia_voltar') {
                telaConfigIA = false;
            }
            renderConfigIA();
        }

        function resolverAcao(key) {
            const isMenu = estadoAtual === 'menu';
            const isGameOver = estadoAtual === 'game_over';
            const isJogando = estadoAtual === 'jogando';

            // Ações globais
            if (key === 'p' || key === 'P') return { acao: 'pausar', tipo: 'single', prevent: true };
            if (key === 'Escape') return { acao: 'menu', tipo: 'single', prevent: true };
            if (key === 'r' || key === 'R') return { acao: 'reiniciar', tipo: 'single', prevent: true };

            // Tela de configuração da IA (local)
            if (telaConfigIA) {
                if (['ArrowUp', 'w', 'W'].includes(key)) return { acao: 'config_ia_cima', tipo: 'single', prevent: true };
                if (['ArrowDown', 's', 'S'].includes(key)) return { acao: 'config_ia_baixo', tipo: 'single', prevent: true };
                if (['ArrowLeft', 'a', 'A'].includes(key)) return { acao: 'config_ia_menos', tipo: 'single', prevent: true };
                if (['ArrowRight', 'd', 'D'].includes(key)) return { acao: 'config_ia_mais', tipo: 'single', prevent: true };
                if (key === ' ' || key === 'Enter') return { acao: 'config_ia_selecionar', tipo: 'single', prevent: true };
                if (key === 'Escape') return { acao: 'config_ia_voltar', tipo: 'single', prevent: true };
                return null;
            }

            // Menus (principal ou game over)
            if (isMenu || isGameOver) {
                if (['ArrowUp', 'w', 'W'].includes(key)) return { acao: 'menu_cima', tipo: 'single', prevent: true };
                if (['ArrowDown', 's', 'S'].includes(key)) return { acao: 'menu_baixo', tipo: 'single', prevent: true };
                if (key === ' ' || key === 'Enter') return { acao: 'menu_selecionar', tipo: 'single', prevent: true };
                return null;
            }

            // Jogo rodando / pausado: entradas contínuas
            switch (key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    return { acao: 'esquerda', tipo: 'cont', prevent: true };
                case 'ArrowRight':
                case 'd':
                case 'D':
                    return { acao: 'direita', tipo: 'cont', prevent: true };
                case 'ArrowUp':
                case 'w':
                case 'W':
                    return { acao: 'cima', tipo: 'cont', prevent: true };
                case 'ArrowDown':
                case 's':
                case 'S':
                    return { acao: 'baixo', tipo: 'cont', prevent: true };
                case ' ':
                case 'z':
                case 'Z':
                    return { acao: 'atirar', tipo: 'cont', prevent: true };
                default:
                    return null;
            }
        }

        document.addEventListener('keydown', (e) => {
            const info = resolverAcao(e.key);
            if (!info) return;
            if (info.prevent && shouldPreventDefault(e.key)) e.preventDefault();

            if (info.tipo === 'cont') {
                if (!pressedKeys.has(e.key)) {
                    pressedKeys.add(e.key);
                    emitirAcao(info.acao, 'pressionar');
                }
            } else {
                emitirAcao(info.acao, 'pressionar');
            }
        });

        document.addEventListener('keyup', (e) => {
            const info = resolverAcao(e.key);
            if (!info || info.tipo !== 'cont') return;
            if (info.prevent && shouldPreventDefault(e.key)) e.preventDefault();

            pressedKeys.delete(e.key);
            emitirAcao(info.acao, 'soltar');
        });

        // Solta todas as teclas se a janela perder o foco (evita movimento preso)
        window.addEventListener('blur', () => {
            pressedKeys.forEach((key) => {
                const info = resolverAcao(key);
                if (info && info.tipo === 'cont') {
                    emitirAcao(info.acao, 'soltar');
                }
            });
            pressedKeys.clear();
        });

        // Socket events
        socket.on('connect', () => {
            statusDiv.textContent = 'Connected to server';
            statusDiv.style.color = '#0f0';
        });

        socket.on('disconnect', () => {
            statusDiv.textContent = 'Disconnected from server';
            statusDiv.style.color = '#f00';
        });

        socket.on('estado_jogo', (estado) => {
            if (estado && estado.estado) {
                if (estado.estado !== estadoAtual) {
                    pressedKeys.clear();
                }
                estadoAtual = estado.estado;
            }

            renderGame(estado);
            atualizarStatus(estado);
        });

        function atualizarStatus(estado) {
            if (!estado) return;
            const mapStatus = {
                menu: 'Menu - selecione com ↑/↓ e Enter/Espaço',
                jogando: estado.pausado ? 'Jogo pausado - P para retomar' : 'Em jogo',
                game_over: 'Game over - use ↑/↓ e Enter/Espaço'
            };

            let texto = mapStatus[estado.estado] || 'Em jogo';
            let cor = '#0f0';

            if (estado.estado === 'menu') cor = '#0ff';
            if (estado.estado === 'game_over') cor = '#f00';
            if (estado.pausado && estado.estado === 'jogando') cor = '#ff0';
            if (estado.deseja_sair) texto = 'Opção sair selecionada - feche a aba para encerrar';

            statusDiv.textContent = texto;
            statusDiv.style.color = cor;
        }

        function renderGame(estado) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!estado) return;

            const estadoNome = estado.estado || 'jogando';

            // Tela de configuração da IA (local, sobrepõe o menu)
            if (telaConfigIA) {
                renderConfigIA();
                return;
            }

            if (estadoNome === 'menu') {
                renderMenu(estado.menu);
                return;
            }

            // Plano de fundo (opcional)
            // ctx.drawImage(sprites.background, 0, 0, canvas.width, canvas.height);

            // Desenho do jogo ativo
            if (estado.jogador) {
                ctx.drawImage(sprites.player, estado.jogador.x, estado.jogador.y, estado.jogador.largura, estado.jogador.altura);
            }

            if (estado.inimigos) {
                estado.inimigos.forEach(inimigo => {
                    let sprite = sprites.enemy1;
                    if (inimigo.tipo === 2) sprite = sprites.enemy2;
                    if (inimigo.tipo === 3) sprite = sprites.enemy3;
                    
                    ctx.drawImage(sprite, inimigo.x, inimigo.y, inimigo.largura, inimigo.altura);
                });
            }

            if (estado.projeteis) {
                estado.projeteis.forEach(projetil => {
                    let sprite = projetil.tipo === 'jogador' ? sprites.bulletPlayer : sprites.bulletEnemy;
                    ctx.drawImage(sprite, projetil.x, projetil.y, projetil.largura, projetil.altura);
                });
            }

            if (estado.explosões) {
                estado.explosões.forEach(explosao => {
                    const size = explosao.tamanho;
                    const offset = size / 2;
                    ctx.drawImage(sprites.explosion, explosao.x - offset, explosao.y - offset, size, size);
                });
            }

            // HUD
            ctx.fillStyle = 'white';
            ctx.font = '20px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${estado.pontuacao}`, 10, 30);
            ctx.fillText(`Lives: ${estado.vidas}`, 10, 60);

            if (estadoNome === 'game_over') {
                renderGameOverMenu(estado.menu_game_over, estado.pontuacao);
                return;
            }

            // Pause overlay
            if (estado.pausado) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#0ff';
                ctx.font = '50px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSADO', canvas.width / 2, canvas.height / 2);

                ctx.fillStyle = 'white';
                ctx.font = '20px Courier New';
                ctx.fillText('Pressione P para retomar', canvas.width / 2, canvas.height / 2 + 50);
            }
        }

        function renderMenu(menuInfo = { opcoes: ['JOGAR COM IA', 'JOGAR SOLO', 'SAIR'], selecionada: 0 }) {
            menuSelecionada = menuInfo.selecionada;  // Atualiza a opção selecionada
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Título em cyan
            ctx.fillStyle = '#0ff';
            ctx.font = 'italic 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('SPACE INVADERS:', canvas.width / 2, 120);
            ctx.fillText('BIA VERSION', canvas.width / 2, 180);

            // Opções do menu
            ctx.font = 'bold 36px Courier New';
            const startY = 280;
            const spacing = 55;
            menuInfo.opcoes.forEach((opcao, idx) => {
                const selecionada = idx === menuInfo.selecionada;
                // SAIR em branco, outras opções em amarelo quando selecionadas
                if (opcao === 'SAIR') {
                    ctx.fillStyle = selecionada ? '#fff' : '#aaa';
                } else {
                    ctx.fillStyle = selecionada ? '#ff0' : '#cc0';
                }
                ctx.fillText(opcao, canvas.width / 2, startY + idx * spacing);
            });
        }

        function renderConfigIA() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.textAlign = 'left';
            const startX = 150;
            const startY = 200;
            const spacing = 80;

            // Campo Layers
            ctx.fillStyle = configIA.campoSelecionado === 0 ? '#fff' : '#aaa';
            ctx.font = '32px Courier New';
            ctx.fillText('Layers:', startX, startY);
            ctx.fillStyle = '#ccc';
            ctx.fillRect(startX + 180, startY - 30, 120, 40);
            ctx.fillStyle = '#000';
            ctx.font = '28px Courier New';
            ctx.fillText(configIA.layers.toString(), startX + 220, startY);

            // Campo Neurônios
            ctx.fillStyle = configIA.campoSelecionado === 1 ? '#fff' : '#aaa';
            ctx.font = '32px Courier New';
            ctx.fillText('Neurônios:', startX, startY + spacing);
            ctx.fillStyle = '#ccc';
            ctx.fillRect(startX + 180, startY + spacing - 30, 120, 40);
            ctx.fillStyle = '#000';
            ctx.font = '28px Courier New';
            ctx.fillText(configIA.neuronios.toString(), startX + 220, startY + spacing);

            // Botão INICIAR
            ctx.textAlign = 'center';
            ctx.fillStyle = configIA.campoSelecionado === 2 ? '#ff0' : '#aa0';
            ctx.font = 'bold 36px Courier New';
            ctx.fillText('INICIAR', canvas.width / 2, startY + spacing * 2 + 40);

            // Instruções
            ctx.fillStyle = '#666';
            ctx.font = '18px Courier New';
            ctx.fillText('Use ↑/↓ para navegar, ←/→ para alterar valores', canvas.width / 2, canvas.height - 60);
            ctx.fillText('Enter para iniciar, ESC para voltar', canvas.width / 2, canvas.height - 35);
        }

        function renderGameOverMenu(menuInfo = { opcoes: [], selecionada: 0 }, pontuacao = 0) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'red';
            ctx.font = '50px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, 220);

            ctx.fillStyle = '#fff';
            ctx.font = '24px Courier New';
            ctx.fillText(`Pontuação: ${pontuacao}`, canvas.width / 2, 260);

            ctx.font = '28px Courier New';
            menuInfo.opcoes.forEach((opcao, idx) => {
                const selecionada = idx === menuInfo.selecionada;
                ctx.fillStyle = selecionada ? '#ff0' : '#fff';
                ctx.fillText(opcao, canvas.width / 2, 320 + idx * 50);
            });

            ctx.fillStyle = '#aaa';
            ctx.font = '20px Courier New';
            ctx.fillText('Use ↑/↓ ou W/S para navegar', canvas.width / 2, 500);
            ctx.fillText('Enter ou Espaço para selecionar', canvas.width / 2, 530);
        }
    </script>
</body>
</html>
